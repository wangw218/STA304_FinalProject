---
title: 'Justin Trudeau would still win 2019 Canadian Federal Election even if "everyone" had voted'
author: "Wen Wang"
date: "`r format(Sys.time(), '%d %B, %Y')`"
thanks: "Code and data are available at: https://github.com/wangw218/STA304_FinalProject"
output:
  bookdown::pdf_document2:
    toc: false
    number_sections: false
    citation_package: natbib

bibliography: references.bib

--- 
```{r setup, include=FALSE, echo=FALSE}
library(tidyverse)
library(lme4)
library(knitr)

# Loading in the cleaned survey Data
survey_data <- read_csv("./../outputs/survey_data.csv")

# Loading in the cleaned census Data
census_data <- read_csv("./../outputs/census_data.csv")

```

## 1. Introduction
The voting process is crucial since it would determine the Prime Minister/President of a country. However, this is not true that everyone eligible to vote had voted in the elections and this phenomenon would probably affect the final results. According to an article in The Economist, if "everyone" had voted in 2016 US presidential election, Hillary Clinton would probably be president.[@CiteIntro1]. Based on the information on Statistics Canada, just over three-quarters (77%) of Canadians reported voting in the 2019 federal election [@CiteIntro2], so it could be inferred that Andrew Scheer would probably win the election if "everyone" had voted. 

So, how to make "everyone" vote? It is time-consuming and cost-consuming and almost impossible to do a survey among the target population, all Canadians citizens who are above 18 in this case since not everyone would like to participate in the survey. One statistic way to solve this is through multilevel regression and poststratification (MRP). The central idea of MRP is to partition the data into thousands of demographic cells, estimate voter intent at the cell level using a multilevel regression model, and finally aggregate the cell-level estimates in accordance with the target population's demographic composition.[@CiteIntro3]. In this report, I will use MRP to identify whether Andrew Scheer or Justin Trudeau would win the 2019 Canadian federal election if "everyone" had voted.

The proceed is as follows. In the Methodology section (Section 2), two data sets (survey data and cencus data) will be introduced to investigate how MRP could be used to predict whether Andrew Scheer or Justin Trudeau would win the 2019 Canadian federal election if "everyone" had voted. Results of the MRP analysis are provided in the Results section (Section 3), and summary and conclusion of the MPR analysis along with Weaknesses and Next Steps are presented in Conclusion section (Section 4).



## 2. Methodology

### 2.1 Data
The survey data is from 2019 Canadian Election Study - Online Survey [@citeSurveyData]. This online sample was for Canadian Election Study and was composed of a two-wave panel with a modified rolling-cross section during the campaign period and a post-election recontact wave. We only focus on campaign period survey (CPS) in this report. The CPS contains an online sample of 37,822 members of the Canadian general population through Qualtrics, with targets stratified by region and balanced on gender and age within each region. It aimed for 50% men and 50% women and aimed to have 28% of our respondents aged 18-34, 33% aged 35-54 and 39% aged 55 and higher. The regions were: Atlantic (Newfoundland and Labrador, New Brunswick, Nova Scotia, Prince Edward Island), Quebec, Ontario Prairies (Manitoba, Saskatchewan, Alberta), and British Columbia. Within each of those regions, the provincial quotas were split evenly. It aimed to have 80% French and 20% English within Quebec, 10% French within the Atlantic region, and 10% French nationally. Respondents needed to be aged 18 or over, and Canadian citizens or permanent residents in order to participate.
[@citeSurveyDataCodeBook]

The census data is from General social survey on Family (cycle 31), 2017 [@CensusDataSource]. The GSS program, established in 1985, conducts telephone surveys across the ten provinces. The GSS is recognized for its regular collection of cross-sectional data that allows for trend analysis, and its capacity to test and develop new concepts that address current or emerging issues. For the census data survey, the target population is all people in Canada who are above 15 years old, excluding those from Yukon, Northwest Territories, and Nunavut. Full-time residents of institutions are also excluded. The frame population is people who could be contacted by telephones. The sampled population is people who took the survey by telephones. Each record in the survey frame was assigned to a stratum within its province. A simple random sample without replacement of records was next performed in each stratum. There are 20,602 respondents and 461 variables in the census data.[@CensusData]

The two plots: Figure \@ref(fig:surveydata) and Figure \@ref(fig:censusdata) shows the raw data information about the provinces of the Survey data and Census Data. From these two plots, we could see Ontario has the largest number of samples, following by Quebec in both of these two datasets. Alberta and British Columbia have the larger number of respondents compared with left. One thing is note is that in GSS, people from Yukon, Northwest Territories, and Nunavut are excluded. Therefore, there are no information about these three provinces in Figure \@ref(fig:censusdata). The number of respondents from these three territories are all extremely low compared with the other 10 provinces from the survey data according to the Figure \@ref(fig:surveydata) so these three territories would not have a great influence on the election result.

```{r surveydata, fig.cap = "Total observations of different provinces in survey Data" , echo = FALSE}
survey_data %>%
  ggplot()+
  geom_bar(aes(province, fill = ..count..),  width = 0.5) +
  labs(caption = "CES Survey Data") +
  theme(axis.text.x = element_text(angle=30, vjust=0.8,hjust = 0.8))+
  scale_fill_gradient(low = "green", high = "red", na.value = NA) +
  xlab("Province") +
  ylab("Count")

```


```{r censusdata,fig.cap = "Total observations of different provinces in census Data", echo= FALSE}
census_data %>%
  ggplot()+
  geom_bar(aes(province, fill = ..count..),  width = 0.5) +
  labs(caption = "GSS Census Data") +
  theme(axis.text.x = element_text(angle=30, vjust=0.8,hjust = 0.8))+
  scale_fill_gradient(low = "green", high = "red", na.value = NA) +
  xlab("Province") +
  ylab("Count")
```


After comparing and analyzing the survey data and census data, I found age, household income, sex, Province are the common and meaning variables between these two datasets in investing the result of whether Andrew Scheer or Justin Trudeau would win the 2019 Canadian federal election if "everyone" had voted.

I did some data cleaning to "match the variables names and values between the two source files, resulting the cleaned data file: survey_data.csv and census_data.csv. (More explanation of how to get these two files are explained in README.md)

For both of the cleaned census data and survey data, they contain the following variables:

"age_group" with range ("45 to 59","60+", "Age 18 to 29", "Age 30 to 44");
"sex" with range (Female, Male);
"household_income" with range ("\$25,000 to \$49,999",  "\$75,000 to \$99,999", "\$100,000 to \$124,999", \$50,000 to \$74,999", "Less than \$25,000" , "\$125,000 and more");

"province" with range ("Quebec","Manitoba","Ontario","Alberta","Nova Scotia","British Columbia", "Saskatchewan", "Prince Edward Island", "New Brunswick", "Newfoundland and Labrador") for census data and three more territories for survey data as shown in Figure \@ref(fig:surveydata) and Figure \@ref(fig:censusdata).

In the survey data, there are two more variables, which called "voteLib"	and "voteCon". Both of them are binary variables, the value 1 indicating the respondent would like to vote the party. The value of these two variables are gotten based on the value of "cps19_votechoice" variable in the raw census dataset. If the value of cps19_votechoice is "Liberal Party", then "voteLib" is 1, otherwise it is 0; Similarly, if the value of cps19_votechoice is "Conservative Party", then "voteCon" is 1, otherwise it is 0.

The overview of our cleaned datasets after removing the NA rows are shown in survey_data Table \@ref(tab:survey) for survey data and Table \@ref(tab:census) for census data.

```{r, echo= FALSE }
survey_data <- na.omit(survey_data)
census_data <- na.omit(census_data)

```


```{r survey, echo= FALSE }
kable(head(survey_data), caption = "Overview of Survey Data")
# head(census_data)
```

```{r census,  echo= FALSE}
kable(head(census_data), caption = "Overview of Census Data")
# head(census_data)
```

What are its key features, strengths, and weaknesses about the study generally?


### 2.2 Model
The model I am using is MRP as mentioned in the Introduction. First, I use the survey data to fit the model and then apply the fitted model to my census data.

I will build two similar MPR models, one for Liberal Party and another for Conservative Party and apply each model to the census data to get the estimates of the probabilities of getting voted among the 10 provinces. Then I will use the estimated probabilities of getting voted in the 10 provinces to get the estimates of seats in each province for Liberal and Conservative Party. In this report, I assume the party which got a higher number of seats would become the governing party. In our analysis, the leader of this party would win the 2019 Canadian federal election if "everyone" had voted. More information about the Canada Election rule can be found in [@electionRule]


## Model Specifics
I will introduce the model about Liberal Party first. I used a logistic regression model as my level 1 model since "voteLib" are binary variables. Since "province" is in Group level based on what we learned in the class, a level 2 model would be built accounted for different intercepts for level 1 model when provinces are different. The level 1 and level 2 models about "Liberal Party" are shown as Equation \@ref(eq:eq1) and Equation \@ref(eq:eq2) respectively :

\begin{equation} \label{eq:eq1}
  log(\frac{\hat{P}}{1-\hat{P}}) = \beta_{0j} + \beta_{1}x_{age\_group,j} + \beta_{3}x_{sex,j} + \beta_{4}x_{household\_income,j}
\end{equation}

\begin{equation} \label{eq:eq2}
  \beta_{0j}=r_{00} + r_{01}W_{j}
\end{equation}

In level 1 model (Equation \@ref(eq:eq1)), $\hat{P_{T}}$ is the dependent variable and represents the probability of voting for Liberal Party.
There are 3 independent variables, $x_{age\_group,j}$, $\beta_{3}x_{sex,j}$,$\beta_{4}x_{household\_income,j}$, age_group, sex and household_income. Since they are all categorical, dummy variable encoding is used for all of them. j is the j province. $\beta_{0j}$ is the intercept, which is the dependent variable in level 2 model. For other $\beta$s, $\beta_1$, $\beta_2$, $\beta_3$, $\beta_4$, they are all slope parameters. Each of them shows the change in log odds of voting for Liberal Party when the x corresponding to $\beta$ changes by 1 in dummy variable coding.

In level 2 model (Equation \@ref(eq:eq2)),$\beta_{0j}$ is the predicated intercept of level 1 model, and each value for j corresponds to a different province. $r_{00}$ is the intercept of level 2 model. $r_{01}$ is the slope parameter. $W_{j}$ is the independent variable that influencing province.

$\beta_{0j}$ represents the intercept parameter, which shows the log odds of voting for Donald Trump when race is American Indian or Alaska Native; age group is 20 or less; gender is female; education is 3rd Grade or less; state is AK(Alaska), and household income is 100,000 to 124,999 USD.

The multilevel regression model about Conservative Party and the understanding is same with Liberal Party's, except now in level 1, the dependent variable $\hat{P$ represents the probability of voting for Conservative Party. 


```{r, echo= FALSE}
model_Lib<- glmer(voteLib~(1|province) + age_group + sex + household_income, data = survey_data, family=binomial)
summary_L = summary(model_Lib)
```

```{r, echo= FALSE}
model_Con <- glmer(voteCon~(1|province) + age_group + sex + household_income, data = survey_data, family=binomial)
summary_C = summary(model_Con)
```



## Post-Stratification

```{r, echo= FALSE}
census_data <-
  census_data%>%
  count(sex, province, age_group,household_income) %>%
  group_by(sex, province, age_group,household_income) %>%
  ungroup()

# Make proportions
census_data <-
  census_data %>%
  group_by(province) %>%
  mutate(total = sum(n)) %>%
  mutate(cell_prop_of_division_total = n / total) %>%
  ungroup()
```
In this section, I would do post-stratification: apply the models I built to the census data. Post-Stratification is the practice of partitioning data into thousands of demographic cells, and final estimation is calculated by the weighted estimate for each cell. This technique could reduce the bias from non-probability based sampling. To begin the post-stratification process, for each province, I partition the data into demographic cells by age_group, sex and household income. This is also the reason why when I do data cleaning process, I make these variables to be categorical. 
To do Post-Stratification on Liberal Party's model: the post-stratification formula (Equation \@ref(eq:eq5)) would be used to calculate the probability of voting for Liberal Party for each province:

\begin{equation} \label{eq:eq5}
  \hat{y}^{PS}=\frac{\Sigma N_{j} \hat{y}_{j}}{\Sigma N_{j}}
\end{equation}

In Equation \@ref(eq:eq5), $\hat{y}^{PS}$ is the estimated probability of voting for Liberal Party in a particular province; $\hat{y}_{j}$ is the estimate of probability of voting for Liberal Party in each cell of that province; $N_{j}$ is the number of voters of the $j^{th}$ cell for that province.

Post-Stratification on Conservative Party's model would use a same equation as Liberal Party's except $\hat{y}^{PS}$ is now the estimated probability of voting for Conservative Party and  $\hat{y}_{j}$ is the estimate of probability of voting for Conservative Party in each cell for a particular province.

Using Post-Stratification, we would get the estimated probability of voting for these two Parties. To figure out whether Andrew Scheer or Justin Trudeau would win the 2019 Canadian federal election if "everyone" had voted, we need to look at the total number of seats these two parties got. I would estimate the number of seats each party got from a province by the product of the probability of the party got voted in that province and the number of seats that province have. Then the total number of seats each party got is the sum of the seats of all provinces. The results would be shown in Result section.


## Model Check
Before moving to the result, we discuss if our model is a good and valid model.

From the Table \@ref(tab:Ttable), most variables about household_income are significant since their p values are small. SexMale is not significant since it has a large p value while the intercept has a very small p value, we could infer SexFemale should be significant. In addition, we could infer and conclude age_group from 45 to 59 should be significant. Overall, most variables are significant. This multilevel regression model is a good model for predicating the probability of voting Liberal Party.

From the Table \@ref(tab:Stable), most variables about age_group, sex and household_income are significant since their p values are small. This multilevel regression model is a good model for predicating the probability of voting Conservative Party.


```{r Ttable, echo = FALSE}
kable(summary_L$coefficients, caption = "Summary of Cofficient of Liberal Party model")
```


```{r Stable, echo = FALSE}
kable(summary_C$Lcoefficients, caption = "Summary of Cofficient of Conservative Party model")
```



```{r,echo = FALSE}
#log estimates for liberal party
census_data$log_estimate_L <-
  model_Lib %>%
  predict(newdata = census_data)

#estimates for liberal party
census_data$estimate_L<-
  exp(census_data$log_estimate_L)/(1+exp(census_data$log_estimate_L))

#estimates for liberal party in each province
estimates_L <- census_data %>%
  mutate(alp_predict_prop_L = estimate_L * cell_prop_of_division_total) %>%
  group_by(province) %>%
  summarise(probability = sum(alp_predict_prop_L))

#log estimates for conservative party
census_data$log_estimate_C <-
  model_Con %>%
  predict(newdata = census_data)

#estimates for conservative party
census_data$estimate_C<-
  exp(census_data$log_estimate_C)/(1+exp(census_data$log_estimate_C))

#estimates for conservative party in each province
estimates_C <- census_data %>%
  mutate(alp_predict_prop_C = estimate_C * cell_prop_of_division_total) %>%
  group_by(province) %>%
  summarise(probability = sum(alp_predict_prop_C))
```

## 3. Results
The Table \@ref(tab:resultT) shows the Probability of voting Liberal Party among each province.

```{r resultT, echo = FALSE}
kable(estimates_L, caption = "Probability of voting Liberal Party among each province")
```

The Table \@ref(tab:resultS) shows the Probability of voting Conservative Party among each province
```{r resultS}
kable(estimates_C, caption = "Probability of voting Conservative Party among each province")
```

Based on Elections Canada [@seats], the number of seats each province/Territory has is as Table \@ref(tab:seatTable)

```{r seatTable, echo = FALSE}
Seats = c(34,42,14,19,7,11,121,4,78,14)
terriotoris  = c ("Yukon",	"Northwest Territories", "Nunavut")
provinces = c(estimates_L$province, terriotoris)
total_seats = c(Seats, c(1,1,1))
seats_table = data.frame("Province/Territory" = provinces , "TotalSeats" =  total_seats)
kable(seats_table, col.names = gsub("[.]", " ", c("Province/Territory", "Total Seats")),  caption = "Allocation of Seats in the House of Commons" )
```

Notice in our census data, the three territories are excluded, therefore the number of seats each party got is estimated by the 10 provinces.

The total number of seats each party is shown in Figure \@ref(fig:seatsResult):
```{r fig, echo = FALSE, fig.cap = "Number of Seats of Liberal Party and Conservative Party""}

Lib_Seats <- round(sum(estimates_L$probability * Seats), digits = 0)
Con_Seats <- round(sum(estimates_C$probability * Seats), digits = 0)
result_table = data.frame("Liberal Party Seats" = Lib_Seats , "Conservative Party Seats" =  Con_Seats)
Party = c("Liberal Party Seats","Conservative Party Seats")
Count = c(Lib_Seats,Con_Seats)
ta = data.frame(x,y)

ggplot(data=ta, aes(x=Party, y=Count)) +
   geom_bar(stat="identity", fill=c("red","steelblue"), width=0.5)+
  geom_text(aes(label=Count), vjust=-0.3, size=3)

```
According to Figure \@ref(fig:seatsResult), we estimate that the number of seats Liberal Party got would be 104 and the number of seats Conservative Party  got would be 97. This is based off our post-stratification analysis of the proportion of voters in each province in favour of Liberal Conservative Party Seats modeled by two multilevel regression models with a binomial family, where the level 1 logistic model accounted for sex, age_group, household_income and level 2 random intercept model accounted for province.

It is clear Justin Trudeau would still win the 2019 Canadian federal election even if "everyone" had voted since Liberal Party has 7 more seats that Conservative Party. The result still would not change even if we assume Conservative Party won the 3 seats in Yukon, Northwest Territories and Nunavut.

## 4. Discussion
In the paper, I invested if 2019 Canadian federal election result would change if "everyone" had voted, specifically, if Andrew Scheer would win the election instead of Justin Trudeau, by using MRP technique. I chose 2019 Canadian Election Study - Online Survey as my survey data and  General social survey on Family (cycle 31), 2017 as my census data. First, I cleaned the data in order to do further analysis. I chose four common and meaning variables between the survey and census data: sex, household income, age, province to do the analysis. In order to do post-stratification, I classified the continuous variables, household income and age, to be categorical with the same range. In addition, I made two new variables, voteLib and voteCon, based on the variable "cps19_votechoice" with the question being "Which party do you think you will vote for?" in Survey data. These two new variables are binary. voteLib stands for "voting for Liberal Party"and value 1 means the respondent would like to vote for it and 0 means not. voteCon has the same logicstic but it's for Conversative Party





```{r surveydata, fig.cap = "Total observations of different provinces in survey Data" , echo = FALSE}
survey_data %>%
  ggplot()+
  geom_bar(aes(province, fill = ..count..),  width = 0.5) +
  labs(caption = "CES Survey Data") +
  theme(axis.text.x = element_text(angle=30, vjust=0.8,hjust = 0.8))+
  scale_fill_gradient(low = "green", high = "red", na.value = NA) +
  xlab("Province") +
  ylab("Count")

```


```{r censusdata,fig.cap = "Total observations of different provinces in census Data", echo= FALSE}
census_data %>%
  ggplot()+
  geom_bar(aes(province, fill = ..count..),  width = 0.5) +
  labs(caption = "GSS Census Data") +
  theme(axis.text.x = element_text(angle=30, vjust=0.8,hjust = 0.8))+
  scale_fill_gradient(low = "green", high = "red", na.value = NA) +
  xlab("Province") +
  ylab("Count")
```

### 4.2 Weaknesses


### 4.3 Next Steps


## Appendix
In this report, we used R [@CiteR], Rstudio [@citeRstudio] and R packages: tidyverse [@package1],lme4 [@package2], knitr [@kable1] [@kable2] [@kable3], cesR [@cesR] and labelled [@labelled].

























